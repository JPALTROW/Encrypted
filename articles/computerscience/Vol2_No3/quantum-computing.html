<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Quantum Computing | Math and CS Research">
    <meta name="keywords" content="Quantum, Encryption, Cryptography, Shor's Algorithm, Lattice, Hash, Elliptic Curve">
    <meta name="author" content="Leon and Mark">
  <meta property="og:title" content="Math and CS Research">
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://mathcsr.org/logo.png">
  <meta property="og:description" content="A Math and CS Research Publication">
  <meta property="og:url" content="">
  <meta property="fb:app_id" content="712553486189960">
    <title>Quantum Computing | Math and CS Research</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X001RVXZHZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-X001RVXZHZ');
</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-181200311-1">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-181200311-1');
</script>

   <script type="text/javascript">
var _0x16d0=['metaKey','6bwtPsH','addEventListener','oncontextmenu','captureEvents','639214bwFvNj','navigator','1239226ymjEuu','46135YiXdag','MOUSEDOWN','getElementById','layers','454159UdgjyX','onmouseup','my-img','all','keydown','728336CVUjpS','ctrlKey','return\x20false','762977DDKmwr','1364924DSPnLI','1BUTpXD','Mac','getElementsByClassName','which','onmousedown','preventDefault'];var _0x2613=function(_0xf00521,_0x34da6a){_0xf00521=_0xf00521-0x194;var _0x16d0df=_0x16d0[_0xf00521];return _0x16d0df;};var _0x5316dc=_0x2613;(function(_0x25c512,_0x110ec0){var _0x598568=_0x2613;while(!![]){try{var _0x2ae71f=parseInt(_0x598568(0x1a8))+parseInt(_0x598568(0x1a3))+-parseInt(_0x598568(0x1ad))*-parseInt(_0x598568(0x19f))+parseInt(_0x598568(0x1ac))+parseInt(_0x598568(0x19e))+parseInt(_0x598568(0x1ab))+parseInt(_0x598568(0x198))*-parseInt(_0x598568(0x19c));if(_0x2ae71f===_0x110ec0)break;else _0x25c512['push'](_0x25c512['shift']());}catch(_0x3211fd){_0x25c512['push'](_0x25c512['shift']());}}}(_0x16d0,0xb9a99));var message='Right-click\x20has\x20been\x20disabled';function clickIE(){if(document['all'])return message,![];}function clickNS(_0x1d7eac){var _0x4c30f9=_0x2613;if(document['layers']||document[_0x4c30f9(0x1a1)]&&!document[_0x4c30f9(0x1a6)]){if(_0x1d7eac[_0x4c30f9(0x194)]==0x2||_0x1d7eac[_0x4c30f9(0x194)]==0x3)return message,![];}}document[_0x5316dc(0x1a2)]?(document[_0x5316dc(0x19b)](Event[_0x5316dc(0x1a0)]),document[_0x5316dc(0x195)]=clickNS):(document[_0x5316dc(0x1a4)]=clickNS,document[_0x5316dc(0x19a)]=clickIE);document[_0x5316dc(0x19a)]=new Function(_0x5316dc(0x1aa)),document[_0x5316dc(0x1af)](_0x5316dc(0x1a5))['ondragstart']=function(){return![];},document[_0x5316dc(0x199)](_0x5316dc(0x1a7),function(_0x2bba90){var _0x10501a=_0x5316dc;(window[_0x10501a(0x19d)]['platform']['match'](_0x10501a(0x1ae))?_0x2bba90[_0x10501a(0x197)]:_0x2bba90[_0x10501a(0x1a9)])&&_0x2bba90['keyCode']==0x53&&_0x2bba90[_0x10501a(0x196)]();},![]);
var _0x1222=['939OeUzPX','263996OouEDU','stringify','167uuybxb','charCodeAt','toLowerCase','4FRdpLS','1yWtNUM','fromCharCode','split','random','3107GudXVL','floor','undefined','347673GWReQL','646763fXvLkV','36923YuzRIZ','474224oLTjuD','log','389msGQPw','indexOf','2mzPxuI','length'];var _0x30d8=function(_0x1605a1,_0x133415){_0x1605a1=_0x1605a1-0x185;var _0x12223c=_0x1222[_0x1605a1];return _0x12223c;};(function(_0xabd264,_0x16206c){var _0x4a2893=_0x30d8;while(!![]){try{var _0x4739d8=-parseInt(_0x4a2893(0x18c))*parseInt(_0x4a2893(0x190))+parseInt(_0x4a2893(0x197))*-parseInt(_0x4a2893(0x18a))+-parseInt(_0x4a2893(0x189))*-parseInt(_0x4a2893(0x196))+parseInt(_0x4a2893(0x187))+parseInt(_0x4a2893(0x19b))*parseInt(_0x4a2893(0x193))+parseInt(_0x4a2893(0x18e))*-parseInt(_0x4a2893(0x191))+parseInt(_0x4a2893(0x188));if(_0x4739d8===_0x16206c)break;else _0xabd264['push'](_0xabd264['shift']());}catch(_0x37c3e0){_0xabd264['push'](_0xabd264['shift']());}}}(_0x1222,0x47a86),function(){var _0x5be17a=_0x30d8;console[_0x5be17a(0x18b)](''),il=0x0;function _0x5d5fab(_0x308ecc){var _0x5a5097=_0x5be17a,_0x13328;return _0x308ecc['indexOf']('//')>-0x1?_0x13328=_0x308ecc[_0x5a5097(0x199)]('/')[0x2]:_0x13328=_0x308ecc[_0x5a5097(0x199)]('/')[0x0],_0x13328=_0x13328[_0x5a5097(0x199)](':')[0x0],_0x13328=_0x13328[_0x5a5097(0x199)]('?')[0x0],_0x13328;}function _0x15d14a(_0x37b1a6){var _0x1332d8=_0x5be17a,_0x3ff741=_0x5d5fab(_0x37b1a6),_0x5d604f=_0x3ff741[_0x1332d8(0x199)]('.'),_0x55df6d=_0x5d604f['length'];if(_0x55df6d==0x2)_0x3ff741=_0x5d604f[0x0];else _0x55df6d>0x2&&(_0x3ff741=_0x5d604f[_0x55df6d-0x2],_0x5d604f[_0x55df6d-0x2][_0x1332d8(0x18f)]==0x2&&_0x5d604f[_0x55df6d-0x1][_0x1332d8(0x18f)]==0x2&&(_0x3ff741=_0x5d604f[_0x55df6d-0x3]));return _0x3ff741;}l=String[_0x5be17a(0x198)](0x4c,0x4f,0x43,0x41,0x54,0x49,0x4f,0x4e)[_0x5be17a(0x195)](),o=String[_0x5be17a(0x198)](0x6f,0x72,0x69,0x67,0x69,0x6e)[_0x5be17a(0x195)](),w=window[l][o],lcl=w[_0x5be17a(0x18d)](String[_0x5be17a(0x198)](0x6c,0x6f,0x63,0x61,0x6c));if(lcl<0x0||il==0x1)var _0x3d18d7=_0x15d14a(w);else return;var _0x51a8fd=[109,116,99,114],_0x5b30fc=[],_0x1a354a=[],_0x2da697='';x=0x0;while(x<_0x51a8fd['length']*0x2){_0x1a354a['push'](_0x3d18d7[_0x5be17a(0x194)](x)),x+=0x2;}if(JSON['stringify'](_0x1a354a)===JSON[_0x5be17a(0x192)](_0x51a8fd)){}else{var _0x1a9db3=0x0;for(var _0x27fa15 in window){_0x1a9db3++;if(_0x1a9db3>0xc8)try{z=Math[_0x5be17a(0x185)](Math[_0x5be17a(0x19a)]()*0x64),window[z]!==_0x5be17a(0x186)?window[_0x27fa15]=window[z]:window[_0x27fa15]=null;}catch(_0x380ed9){}}}}());
</script>
 
<link rel=icon href=/favicon.png sizes=32x32 type=image/png><link rel=icon href=/favicon.png sizes=16x16 type=image/png><link href=/css/bootstrap.min.css rel=stylesheet><style>.bd-placeholder-img{font-size:1.125rem;text-anchor:middle;-webkit-user-select:none;-moz-user-select:none;user-select:none}.brand{Position:absolute left: 50%;margin-left:-120px!important;-webkit-transform:translateX(+15%)}img{-webkit-user-drag:none;-khtml-user-drag:none;-moz-user-drag:none;-o-user-drag:none;user-drag:none}@media (min-width:768px){.bd-placeholder-img-lg{font-size:3.5rem}body{font-size:1em}}@media print{body{background-color:transparent;color:#000;font-size:12pt}h2,h3,p{orphans:3;widows:3}h2,h3,h4{page-break-after:avoid}}.container-fluid{padding-right:10%;padding-left:10%}p{margin:1em 0}h1,h2,h3,h4,h5,h6{margin-top:1.4em}.title{font-size:2.5em}h1{Font-size:1.9em}h2{Font-size:1.4em}h3,h4{font-size:1em;font-style:italic}h5,h6{font-weight:400}ol,ul{padding-left:1.7em;margin-top:1em}li>ol,li>ul{margin-top:0}blockquote{margin:1em 0 1em 1.7em;padding-left:1em;border-left:2px solid #e6e6e6;color:#606060}code{font-size:85%;margin:0}pre{margin:1em 0;overflow:auto}pre code{padding:0;overflow:visible}.sourceCode{background-color:transparent;overflow:visible}hr{background-color:#1a1a1a;border:none;height:1px;margin:1em 0}table{margin:1em 0;border-collapse:collapse;width:100%;overflow-x:auto;display:block;font-variant-numeric:lining-nums tabular-nums}table caption{margin-bottom:.75em}tbody{margin-top:.5em;border-top:1px solid #1a1a1a;border-bottom:1px solid #1a1a1a}th{border-top:1px solid #1a1a1a;padding:.25em .5em .25em .5em}td{padding:.125em .5em .25em .5em}#TOC li{list-style:none}#TOC a:not(:hover){text-decoration:none}code{white-space:pre-wrap}span.smallcaps{font-variant:small-caps}span.underline{text-decoration:underline}div.column{display:inline-block;vertical-align:top;width:50%}div.hanging-indent{margin-left:1.5em;text-indent:-1.5em}ul.task-list{list-style:none}</style><link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900&display=swap" rel=stylesheet><link href=/css/blog.css rel=stylesheet><div class=container><header class="blog-header py-3"><div class="row flex-nowrap justify-content-between align-items-center"><div class="col-4 pt-1"><a class=link-secondary href=https://docs.google.com/forms/d/e/1FAIpQLScARm0MoVGwxdH0w9PWmZNzjIf4CUJPzLcqDJ0UGob88ALIBg/viewform>Join Us</a></div><div class="col-4 text-center brand"><a class="blog-header-logo text-dark" href=/ ><img src=/logo.png class="img-responsive center-block" height=118 width=200></a></div><div class="col-4 d-flex justify-content-end align-items-center"><a class="btn btn-sm btn-outline-secondary" href=/subscribe>Subscribe</a></div></div></header><div class="nav-scroller py-1 mb-2"><nav class="nav d-flex justify-content-between"><a class="p-2 link-secondary" href=/ >This Edition</a> <a class="p-2 link-secondary" href=/appliedmath>Applied Math</a> <a class="p-2 link-secondary" href=/computerscience>Computer Science</a> <a class="p-2 link-secondary" href=/features>Features</a> <a class="p-2 link-secondary" href=/problemsolving>Problem Solving</a> <a class="p-2 link-secondary" href=/puzzles>Puzzles</a> <a class="p-2 link-secondary" href=/research>Research</a> <a href=/editions class="link-secondary p-2">Editions</a> <a class="p-2 link-secondary" href=/staff>Staff</a></nav></div></div><main class=container-fluid><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js></script><!--[if lt IE 9]><script src=//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js></script><![endif]--><center><header id=title-block-header><h1 class=title>Quantum Computing</h1><p class=author>Leon and Mark</header></center><h1 id=introduction>Introduction</h1><div class=center><p>If computers that you build are quantum, Then spies everywhere will all want ’em. Our codes will all fail, And they’ll read our email, Till we get crypto that’s quantum, and daunt ’em. – Jennifer and Peter Shor</div><h1 id=shors-algorithm>Shor’s Algorithm</h1><p>Currently the fastest classical prime factoring algorithm is the general number factoring sieve with a runtime of approximately <span class="math inline">\(\exp \left( \left( \sqrt[3]{\frac{64}{9}} + o(1) \right) (\ln n)^{\frac13} (\ln \ln n)^{\frac23} \right) = L_n [ \frac13, \sqrt[3]{\frac{64}{9}} ]\)</span>. One the other, Shor’s Algorithm has a runtime slightly slower than <span class="math inline">\(O(n^3)\)</span>.<h2 id=shors-algorithm-1>Shor’s Algorithm</h2><p>In this article I will present how Shor’s Algorithm backwards from how is it usually presented. Instead of introducing the tools then using the tools to construct Shor’s Algorithm, I will use elements of the final alogrithm to motivate the each part. Shor’s Algorithm looks to factor numbers of the form <span class="math inline">\(N=a \cdot b\)</span> where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are prime. It turns out that RSA is most secure when <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are both prime so <span class="math inline">\(N\)</span> can be as large as possible. If <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> were instead factorable themselves into smaller primes, elementary number theory would easily be able to use the smallest prime factor to find the rest of the factors and break the key. We begin by guessing a number <span class="math inline">\(g\)</span>. If <span class="math inline">\(g\)</span> is factor of <span class="math inline">\(N\)</span>, we’re down. If <span class="math inline">\(g\)</span> shares a factor with one of the factors of <span class="math inline">\(N\)</span>, then we can run Euclid’s Algorithm to find the GCD which runs very fast relative to factoring itself on a classical number and we are done. However, it is extremely unlikely that our guess <span class="math inline">\(g\)</span> will be either a factor or share factors with a factor of <span class="math inline">\(N\)</span>. Shor’s algorithm gives a way to turn our crappy guess <span class="math inline">\(g\)</span> to one that is much more likely to share factors with <span class="math inline">\(N\)</span> and here is how.<h2 id=quantum-fourier-transform>Quantum Fourier Transform</h2><p>So how exactly do we find this phase. You may remember that the Fourier Transform can be used to decompose sums of sine waves into the frequencies of each of the individual sine wave. The Quantum fourier transform (QFT) is in turn a version of the Discrete Fourier Transform (DFT). Instead of sampling the entire function, DFT samples our function at regularly spaced intervals to approximate the frequency of the underlining functions. The DFT is defined that for the vector input <span class="math inline">\(x = (x_0, x_2, x_3 \ldots x_{n-1}\)</span> the output <span class="math inline">\(y = (y_0, y_2, y_3 \ldots y_{n=1}\)</span> is where <span class="math inline">\(n\)</span> is the number of elements. In our case, each element of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is a bit that is either 0 or 1. Thus, <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are n-bit strings that can represent <span class="math inline">\(2^n\)</span> numbers. We then define <span class="math inline">\(N = 2^n\)</span> and for simplicity we will only deal with unsigned positive integers. We thus define the DFT by<p><span class="math display">\[y_k \equiv \frac{1}{\sqrt{N}} \sum_{j = 0}^{N -1} x_j e^{2 \pi ijk/N}\]</span><p>We use our definition of the DFT to define the QFT in an analogous way. For a quantum input state <span class="math inline">\(\ket{j} = \ket{j_0 j_1 j_2} \ldots j_{n-1}\)</span> which represent the individual state of the qubits that make up <span class="math inline">\(\ket{x}\)</span> and a similar defined quantum output state <span class="math inline">\(\ket{k} = \ket{k_0 k_1 k_2 \ldots k_{n-1}}\)</span>, the QFT is defined by<p><span class="math display">\[\ket{j} \mapsto \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2 \pi ijk/N} \ket{k}\]</span> This can be written simply as <span class="math display">\[\sum_{j=0}^{N-1} x_j \ket{j} \mapsto \sum_{k=0}^{N-1} y_k \ket{k}\]</span><p>with a bit of algebra we can show that<p><span class="math display">\[\ket{j} \rightarrow \frac{1}{2^{n/2}} \sum_{k=0}^{2^n-1} e^{2 \pi ijk/{2^n}} \ket{k} =\]</span> <span class="math display">\[\frac{1}{2^{n/2}} \sum_{k_1=0}^1 \ldots \sum_{k_n=0}^1 e^{2 \pi ij (\sum_{l=1}^n k_l 2^{-l})} \ket{k_1 \ldots k_n} =\]</span> <span class="math display">\[\frac{1}{2^{n/2}} \sum_{k_1=0}^1 \ldots \sum_{k_n=0}^1 \bigotimes_{l=1}^n e^{2 \pi ijk_l 2^{-l}} \ket{k_l} =\]</span> <span class="math display">\[\frac{1}{2^{n/2}} \bigotimes_{l=1}^n \left[ \sum_{k_l=0}^1 e^{2 \pi ijk_l 2^{-l}} \ket{k_l} \right] =\]</span> <span class="math display">\[\frac{1}{2^{n/2}} \bigotimes_{l=1}^n [ \ket{0} + e^{2 \pi ij 2^{-l}} \ket{1} ] =\]</span> <span class="math display">\[\frac{1}{2^{n/2}} [(\ket{0} +e^{2 \pi i j/2})\ket{1}) \otimes (\ket{0} + e^{2 \pi i j/2^2} \ket{1}) \otimes \ldots]\]</span><p>This defintion of the QFT is so useful you may consider it to be the defintion of the QFT. Like all quantum gates, the QFT is unitary. This proves to be important as it means its eigenvalue is real. Remember the eigenvalue is used to estimate the phase. This will be important later on.<h1 id=post-quantum-safety>Post-Quantum Safety</h1><p>With the discovery of Shor’s algorithm and the invention of quantum computers, it is reasonable to question if there will be defenses against it. Currently, the encryption methods that are used are quantum proof because even with the best implementation of Shor’s algorithm, it can only calculate the factor of numbers that is a few digits long using a couple quantum bits. This is not even close to enough to decrypt some of the smaller numbers used in encryption. However, there are research on how we can better our encryptions against the threat of quantum computers. There are four different methods.<h2 id=lattice-based-encryption>Lattice-Based Encryption</h2><p>Lattice is defined as any graph of regular square points that goes to infinity. A vector is simply a point and it will have 2 coordinates on a 2-dimensional plane and 3 coordinates in the 3-dimensional space. If a vector is “long” from the origin, the vector is far from the origin and if it is “short” from the origin, the vector is close to the origin. Since lattices are infinite, but computers have a finite storage space, we need to use a basis of a lattice.a small amount of vectors that can represent the lattice. In order to generate one of these lattices, pick two points that would not be on the same line going through the origin. Next, choose 2 whole numbers and multiply the first number with the first coordinate and the second number with the second coordinate. Put the two coordinates together and you will get the third point and rinse and repeat. With this method, we can generate a whole grid or lattice of evenly spaced points. However, a given lattice can have multiple starting pairs of coordinates. For example, a lattice created using the points (2, 0) and (0,2) can be generated with (-2, 0) and (0, -2) or (4, 2) and (2, 2) as well. A basis that is short consists of short vectors and a basis that is long consists of long vectors. The short bases are the more useful one in lattice problems. One of the most important problems in lattice-based cryptography is the “Short Vector Problem.” This problem gives us a long basis in lattice L and asks us to find a grid point in L that is as close to the origin as possible. What makes this question difficult is that we are given a basis with long vectors so it’s not easy to find which short vectors will result in the long vector. In addition, because it is in cryptography, these lattices will be in higher dimensions so they will have tens of thousands of coordinates rather than just two or three coordinates.<h2 id=multivariate-cryptography>Multivariate Cryptography</h2><p>This type of cryptography includes cryptographic systems such as the Rainbow Scheme, also called the Unbalance Oil and Vinegar(UOV) scheme. This is a modified version of the Oil and Vinegar Scheme designed by J. Patarin. This cryptography’s security relies on an NP-hard mathematical problem. To create and validate signatures a minimal quadratic equation system has to be solved. Solving <em>m</em> equations with <em>n</em> variables is very difficult for quantum computers to be able to solve. As stated before, the UOV relies on solving <em>m</em> equations with <em>n</em> variables, with the equation system as the public key. Because a standard computer can not process <em>n</em> variables in a reasonable time and would need a lot of resources to do it. This is where the private key come into play. The key consist of three parts: two Affine transformations <em>T</em> and <em>S</em> and polynomial vector <em>P</em>. The transformations are used to transform elements in certain groups. The <em>P</em> provided certain tools for the equations creation. To create a valid signature, a list of <em>y</em>, which will be our message that needs to be signed, that each <em>y</em> value in the list will be obtained by running functions on our valid signature which will be our list of <em>x</em> values. In order for a given <em>y</em> to be signed. a series of steps need to be performed on it. First, the message needs to be transformed to fit the equation system which is what our <em>T</em> will be used for. It will spilt the message into acceptable pieces which will be a list of <em>y</em>. Next the equation will need to be build and every equation will have the same form:<p><span class="math display">\[y_i = \sum \gamma_{\textit{ijk}} \alpha_\textit{j} \alpha^{'}_\textit{k} + \sum \lambda_{\textit{ijk}} \alpha^{'}_\textit{j} \alpha^{'}_\textit{k} + \sum \xi_{\textit{ij}} \alpha_\textit{j} + \sum \xi^{'}_{\textit{ij}} \alpha^{'}_\textit{j} + \delta_i\]</span><p>The next steps sign the given message <em>y</em> and the valid signature, <em>x</em>, will be the result. First the coefficients <span class="math inline">\((\gamma_{ijk}, \lambda_{ijk}, \xi_{ij}, \xi^{'}_{ij}, \delta_i)\)</span> must be chosen secretly. The vinegar variables <span class="math inline">\((a^{'}_j)\)</span> are chosen randomly. The result linear equation system gets solved for the oil variable <span class="math inline">\(({a_i})\)</span>. The variables create the pre-signature <span class="math inline">\(A = (a_{1}. ..., a_{n}, a^{'}_{1}, a^{'}_{v})\)</span>. Finally <em>A</em> get transformed by the private affine transformation <em>S</em> to <em>x</em>. In order to valid a signature, we need use a equation system that is only a slightly modified version of the one we used to create the signature. Only this time every equation has to solved in order for a signature to be valid. If an attacker is tries to break the encryption, they would be able to do any thing because of the fact that they do not know the oil and vinegar variables and the secret coefficients. If the <span class="math inline">\(y_i\)</span> is equal to the corresponding part of the original message then the verification is done. However, one drawback is the key-length. Because the public key is literally a whole equations system that can take up spaces up to some kilobytes, if someone wants to verify a signature they need to all the equations in order to compute the encrypted message and compare that to the original message.<h2 id=hash-based-cryptography>Hash-based Cryptography</h2><p>Hash-based cryptography uses an input string and produces a fixed-size output. There are multiple security requirements to make a cryptographic hash, but we will focus on three here. One of these is preimage resistance which is to make the output time-comsuming to find that the input is so that attackers cannot just brute-force their way in. A second-preimage resistance is to make sure that there is not a second input that can result in the output. The last one is collision resistance which make sure that the when a function is applied to to the input, the result should not be able to be reached by passing a different number through the function. In other words, f(x) should be be able to equal to f(h) The first hashed-based signature scheme was created in 1979 by Leslie Lamport. He found that by using a one-way function it is possible to create a powerful signature scheme. For example, if we want to sign 256 bit messages, we need a secret key and a private key. We first generate 512 separate random bit strings and arrange them into two separate lists and will be referred to by their index and is what we will be signing with. To create the public key, we will hash each of those random string with the function H(•) which will turn the two secret key lists into two public key lists. The public key can be shared or whatever we want to do with it. Now if we want to sign something with the secret key, we take the index of each bit in the message and correspond it with either the index of a bit in the first secret key list of the index of a bit in the second secret key list. Once we finish assigning, we can concatenate the result and the message would be encrypted. If the message gets to the intended recipient, then they would be able to just take the message and hash everything back and match it with which ever list or index it is suppose to be. This methods seems alright but one crucial problem is that this method can only be able to sign one message. This caused by the fact that the signatures shows one of the two secret key values at each position. This way if two messages were signed and differs at any point it would reveal the secret key for the position. This would allow someone else to sign a message that the original owner did not sign and how much they would be able to affect the message depends on the amount of messages the attacker has to work with. So how can we solve this problem of the inability to sign multiple message? One idea to this problem is to just increase the length of the secret key and public key every time we sign a new message. This method is obviously terrible because of how large the keys will end up being if this method is used. Here is where Merkle comes in. He proposed that first to generate <em>n</em> amount of Lamport keypairs. Next place each public key at one leaf of a Merkle Hash tree and calculate the root of the tree. The root will serve as the master public key. To get this root, we take the two lists of public keys and concatenate the result after hash each of them. Repeat this step for another two lists and finally, concatenate the result after hashing each of the new lists and the result of this will be the root of the tree. Basically how it works is that Computer A sends a hash file to Computer B. Computer B would then check the file against the root of the tree. If there is no differences, then it is all good. Otherwise, the computer will requests the roots of the subtree of the hash. Computer A would create the request hash and sent it back to Computer B. The last two steps would repeat until it matches. As said before Merkle’s method still has the downside of getting too big. However, what if we just do not sign all of the messages? What if we just sign the message bits that equal to 1. This would cut the space needed by half due to an entire list being rid off. However, this is not a very good method because if someone wanted to change a signed message from “1111” to “0000”, they would just have to delete some parts of the signature. To fix this hole, we can just check the number of zero bits in the message. If the number of zero bits does not match the original number of zero bits, the signature would be rejected. The checksum is in binary and is also signed with the message so messing with the checksum would not be possible. The method above does a good job at reducing the size, but some signatures and public key size are still thousands of bits long. Robert Winternitz proposed an idea: what if, instead of signing with bits we use bytes, which can store 8-bits of information. His idea was that since storing and distributing 265 random lists is too storage consuming, what if we only generate the lists when we need them? This method required us to first generate a list that will serve as the initial secret key. To get the next list, we just hash each element forward to get the next set of secret key and so on and so forth. To get the public key, Winternitz suggested that the public key would just be the last list or the 256th list. This method is very clever way that allows the fact that any given secret key, if we hash it forward, we would get the public key. The way we would use this is that we check the value of the message byte and we would use the corresponding secret key list. To prevent forgeries, Winternitz came up with another trick. The Winternitz checksum works by summing the difference between 255 and the value of each message bytes signed. The sum would also be in base-265 and would be added to the message to be signed. For example, if a message was (0, 0, 0, 0) the checksum would be 1020 which in base-256 is (3, 252). Even though these methods were developed in the late 1900s, most hash-base signatures are not vulnerable to Shor’s algorithm. It could can lower the effectiveness of the security but simply increasing the capacity and output size of the hash function.<h2 id=supersingular-elliptic-curve-isogeny-cryptography>Supersingular Elliptic Curve Isogeny Cryptography</h2><p>Elliptic curve cryptography is similar to the RSA in terms of security except elliptic curve cryptography used fewer bits. Using ecliptic curve required less power, smaller chip size, and increase in speed. There is two type of elliptic curve cryptography. The Diffie-Hellman Key Exchange Encryption works as followed. Say two people want to make a common key so that they can exchange messages secretly. Assuming that the only way the two people had not contact each other beforehand and can only contact through a public channel. Now we use Diffie-Hellman Key Exchange to get the private key. The two people would agree on an elliptic curve, <em>E</em> over a finite field, <span class="math inline">\(\textbf{F}_\textit{q}\)</span> such that the discrete logarithm problem is contained in <span class="math inline">\(\textit{E}(\textbf{F}_\textit{q})\)</span>. A point <em>P</em> that is contained on <span class="math inline">\(\textit{E}(\textbf{F}_\textit{q})\)</span> such that the subclass generated by <em>P</em> has a large order. These are usually chosen such that the order is a large prime number. Person A would chose a secret number <em>a</em> and compute aP and sends that to the other person. Person B would do the same so that Person A would get bP and Person B would have aP. They would apply their secret number to the recently obtained number and they both would get abP and now would use abP to create a key. Let’s say there is a third person that has been listening to the conversation. The only information this person would have is the curve E, the finite field, <span class="math inline">\(\textbf{F}_\textit{q}\)</span>, the points P, aP, bP. They would have to use these information to compute what abP. The only problem that is there is no way of doing it without solving the discrete log problem for our curve. There is a proof to show abP is hard to find, but it is quite complicated. The second elliptic curve cryptography is the Massey-Omura Encryption. Say the two people wanted to make another encryption method. They would agree on another elliptic curve <em>E</em> over a finite field, <span class="math inline">\(\textbf{F}_\textit{q}\)</span> such that the discrete logarithm problem is contained in <span class="math inline">\(\textit{E}(\textbf{F}_\textit{q})\)</span> and lets say N = <span class="math inline">\(\textit{E}(\textbf{F}_\textit{q})\)</span>. Basically Person A will choose a point in <span class="math inline">\(\textit{E}(\textbf{F}_\textit{q})\)</span>, M, to hide their message. They will then choose a secret number, <span class="math inline">\(m_A\)</span>, where the greatest common multiple between <span class="math inline">\(m_A\)</span> and N is 1. They will find the value for <span class="math inline">\(m_{A}M\)</span> and send that to Person B. Person B would choose his own secret number <span class="math inline">\(m_B\)</span>, where the greatest common multiple between <span class="math inline">\(m_B\)</span> and N is 1 and calculate <span class="math inline">\(m_{B}m_{A}M\)</span>. They would sent this back to Person A where they would calculate <span class="math inline">\(m_a^{-1}\)</span> and be sent back to person B. Person B would calculate <span class="math inline">\(m_b^{-1}\)</span> and reads the message. In simpler terms, suppose Person A places a message in a box and locks it with their lock and give it to Person B. Person B would put their own lock on it and give it back to Person A who will open their lock and send it back again. Now the only lock on the box is the one Person B had placed so they can just open the box and read the message. Although cryptography using elliptic curve has been around for 20 years and is considered the best concept of cryptography, but there are some problems with this cryptography method. One major roadblock has been the intellectual property environment surrounding elliptic curves that prevented the implementations and use. However, as we go into the future, it would be used more and more and will become a part of our normal encryption methods.<ol style=word-wrap:break-word><h1 id=references>References</h1><li><p>Oceania, E. (2020, November 30). Beating the code breakers: How quantum computing changes everything. Retrieved April 01, 2021, from https://www.ey.com/en_au/consulting/how-quantum-computing-changes-everything</ol></main><script>var maxHeight=0;$(".row").each((function(){$(this).height()>maxHeight&&(maxHeight=$(this).height())})),$(".row").height(maxHeight)</script><footer class=blog-footer><a href="https://us7.list-manage.com/contact-form?u=bd1a0a18ff760b00bf541b12d&form_id=b47981c22ebecdf4a32acfec1a5f0fc7">Contact Us</a> | <a href=https://docs.google.com/forms/d/e/1FAIpQLScARm0MoVGwxdH0w9PWmZNzjIf4CUJPzLcqDJ0UGob88ALIBg/viewform>Join Us</a><br>Copyright © 2021 Math and CS Research.</footer><script src=https://code.jquery.com/jquery-3.4.1.slim.min.js integrity=sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js integrity=sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js integrity=sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6 crossorigin=anonymous></script>
