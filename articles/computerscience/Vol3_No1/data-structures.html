<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Data Structures and Algorithms - The Segment Tree | Math and CS Research">
    <meta name="keywords" content="Data Structures, Algorithms, Segment Tree, Recursion, Binary Tree">
    <meta name="author" content="Naowal Rahman">
  <meta property="og:title" content="Math and CS Research">
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://mathcsr.org/soc.png">
  <meta property="og:description" content="A Math and CS Research Publication">
  <meta property="og:url" content="">
  <meta property="fb:app_id" content="712553486189960">
    <title>Data Structures and Algorithms - The Segment Tree | Math and CS Research</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X001RVXZHZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-X001RVXZHZ');
</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-181200311-1">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-181200311-1');
</script>

   <script type="text/javascript">
var _0x16d0=['metaKey','6bwtPsH','addEventListener','oncontextmenu','captureEvents','639214bwFvNj','navigator','1239226ymjEuu','46135YiXdag','MOUSEDOWN','getElementById','layers','454159UdgjyX','onmouseup','my-img','all','keydown','728336CVUjpS','ctrlKey','return\x20false','762977DDKmwr','1364924DSPnLI','1BUTpXD','Mac','getElementsByClassName','which','onmousedown','preventDefault'];var _0x2613=function(_0xf00521,_0x34da6a){_0xf00521=_0xf00521-0x194;var _0x16d0df=_0x16d0[_0xf00521];return _0x16d0df;};var _0x5316dc=_0x2613;(function(_0x25c512,_0x110ec0){var _0x598568=_0x2613;while(!![]){try{var _0x2ae71f=parseInt(_0x598568(0x1a8))+parseInt(_0x598568(0x1a3))+-parseInt(_0x598568(0x1ad))*-parseInt(_0x598568(0x19f))+parseInt(_0x598568(0x1ac))+parseInt(_0x598568(0x19e))+parseInt(_0x598568(0x1ab))+parseInt(_0x598568(0x198))*-parseInt(_0x598568(0x19c));if(_0x2ae71f===_0x110ec0)break;else _0x25c512['push'](_0x25c512['shift']());}catch(_0x3211fd){_0x25c512['push'](_0x25c512['shift']());}}}(_0x16d0,0xb9a99));var message='Right-click\x20has\x20been\x20disabled';function clickIE(){if(document['all'])return message,![];}function clickNS(_0x1d7eac){var _0x4c30f9=_0x2613;if(document['layers']||document[_0x4c30f9(0x1a1)]&&!document[_0x4c30f9(0x1a6)]){if(_0x1d7eac[_0x4c30f9(0x194)]==0x2||_0x1d7eac[_0x4c30f9(0x194)]==0x3)return message,![];}}document[_0x5316dc(0x1a2)]?(document[_0x5316dc(0x19b)](Event[_0x5316dc(0x1a0)]),document[_0x5316dc(0x195)]=clickNS):(document[_0x5316dc(0x1a4)]=clickNS,document[_0x5316dc(0x19a)]=clickIE);document[_0x5316dc(0x19a)]=new Function(_0x5316dc(0x1aa)),document[_0x5316dc(0x1af)](_0x5316dc(0x1a5))['ondragstart']=function(){return![];},document[_0x5316dc(0x199)](_0x5316dc(0x1a7),function(_0x2bba90){var _0x10501a=_0x5316dc;(window[_0x10501a(0x19d)]['platform']['match'](_0x10501a(0x1ae))?_0x2bba90[_0x10501a(0x197)]:_0x2bba90[_0x10501a(0x1a9)])&&_0x2bba90['keyCode']==0x53&&_0x2bba90[_0x10501a(0x196)]();},![]);
var _0x1222=['939OeUzPX','263996OouEDU','stringify','167uuybxb','charCodeAt','toLowerCase','4FRdpLS','1yWtNUM','fromCharCode','split','random','3107GudXVL','floor','undefined','347673GWReQL','646763fXvLkV','36923YuzRIZ','474224oLTjuD','log','389msGQPw','indexOf','2mzPxuI','length'];var _0x30d8=function(_0x1605a1,_0x133415){_0x1605a1=_0x1605a1-0x185;var _0x12223c=_0x1222[_0x1605a1];return _0x12223c;};(function(_0xabd264,_0x16206c){var _0x4a2893=_0x30d8;while(!![]){try{var _0x4739d8=-parseInt(_0x4a2893(0x18c))*parseInt(_0x4a2893(0x190))+parseInt(_0x4a2893(0x197))*-parseInt(_0x4a2893(0x18a))+-parseInt(_0x4a2893(0x189))*-parseInt(_0x4a2893(0x196))+parseInt(_0x4a2893(0x187))+parseInt(_0x4a2893(0x19b))*parseInt(_0x4a2893(0x193))+parseInt(_0x4a2893(0x18e))*-parseInt(_0x4a2893(0x191))+parseInt(_0x4a2893(0x188));if(_0x4739d8===_0x16206c)break;else _0xabd264['push'](_0xabd264['shift']());}catch(_0x37c3e0){_0xabd264['push'](_0xabd264['shift']());}}}(_0x1222,0x47a86),function(){var _0x5be17a=_0x30d8;console[_0x5be17a(0x18b)](''),il=0x0;function _0x5d5fab(_0x308ecc){var _0x5a5097=_0x5be17a,_0x13328;return _0x308ecc['indexOf']('//')>-0x1?_0x13328=_0x308ecc[_0x5a5097(0x199)]('/')[0x2]:_0x13328=_0x308ecc[_0x5a5097(0x199)]('/')[0x0],_0x13328=_0x13328[_0x5a5097(0x199)](':')[0x0],_0x13328=_0x13328[_0x5a5097(0x199)]('?')[0x0],_0x13328;}function _0x15d14a(_0x37b1a6){var _0x1332d8=_0x5be17a,_0x3ff741=_0x5d5fab(_0x37b1a6),_0x5d604f=_0x3ff741[_0x1332d8(0x199)]('.'),_0x55df6d=_0x5d604f['length'];if(_0x55df6d==0x2)_0x3ff741=_0x5d604f[0x0];else _0x55df6d>0x2&&(_0x3ff741=_0x5d604f[_0x55df6d-0x2],_0x5d604f[_0x55df6d-0x2][_0x1332d8(0x18f)]==0x2&&_0x5d604f[_0x55df6d-0x1][_0x1332d8(0x18f)]==0x2&&(_0x3ff741=_0x5d604f[_0x55df6d-0x3]));return _0x3ff741;}l=String[_0x5be17a(0x198)](0x4c,0x4f,0x43,0x41,0x54,0x49,0x4f,0x4e)[_0x5be17a(0x195)](),o=String[_0x5be17a(0x198)](0x6f,0x72,0x69,0x67,0x69,0x6e)[_0x5be17a(0x195)](),w=window[l][o],lcl=w[_0x5be17a(0x18d)](String[_0x5be17a(0x198)](0x6c,0x6f,0x63,0x61,0x6c));if(lcl<0x0||il==0x1)var _0x3d18d7=_0x15d14a(w);else return;var _0x51a8fd=[109,116,99,114],_0x5b30fc=[],_0x1a354a=[],_0x2da697='';x=0x0;while(x<_0x51a8fd['length']*0x2){_0x1a354a['push'](_0x3d18d7[_0x5be17a(0x194)](x)),x+=0x2;}if(JSON['stringify'](_0x1a354a)===JSON[_0x5be17a(0x192)](_0x51a8fd)){}else{var _0x1a9db3=0x0;for(var _0x27fa15 in window){_0x1a9db3++;if(_0x1a9db3>0xc8)try{z=Math[_0x5be17a(0x185)](Math[_0x5be17a(0x19a)]()*0x64),window[z]!==_0x5be17a(0x186)?window[_0x27fa15]=window[z]:window[_0x27fa15]=null;}catch(_0x380ed9){}}}}());
</script>
 
<link rel="icon" href="/favicon.png" sizes="32x32" type="image/png">
<link rel="icon" href="/favicon.png" sizes="16x16" type="image/png">

    <!-- Bootstrap core CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">

    <style>
      .bd-placeholder-img {
        font-size: 1.125rem;
        text-anchor: middle;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
      }

.brand {
    Position: absolute
    left: 50%;
    margin-left: -120px !important;
-webkit-transform: translateX(+15%);
   
}

img {
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}


      @media (min-width: 768px) {
        .bd-placeholder-img-lg {
          font-size: 3.5rem;
        }
        body {
         font-size: 1em;
        }

      }


    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
.container-fluid {
    padding-right: 14%;
    padding-left: 14%;
}
    p {
      margin: 1em 0;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
.title{
    font-size: 2.5em;
}
    h1{
      Font-size: 1.9em;
    }
    h2{
      Font-size: 1.4em;
    }
    h3, h4 {
      font-size: 1em;
      font-style: italic;
    }
    h5, h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {

      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}

pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

    </style>

    
    <!-- Custom styles for this template -->
    <link href="https://fonts.googleapis.com/css?family=Playfair&#43;Display:700,900&amp;display=swap" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="/css/blog.css" rel="stylesheet">
  </head>
  <body>
    
<div class="container">
  <header class="blog-header py-3">
    <div class="row flex-nowrap justify-content-between align-items-center">
      <div class="col-4 pt-1">
        <a class="link-secondary" href="https://docs.google.com/forms/d/e/1FAIpQLScARm0MoVGwxdH0w9PWmZNzjIf4CUJPzLcqDJ0UGob88ALIBg/viewform">Join Us</a>
      </div>
      <div class="col-4 text-center brand" >
        <a class="blog-header-logo text-dark" href="/"><img src="/logo.png" class="img-responsive center-block" height='118' width='200'></a>
      </div>
	<div class="col-4 d-flex justify-content-end align-items-center">
        <a class="btn btn-sm btn-outline-secondary" href="/subscribe">Subscribe</a>
      </div>
    </div>
  </header>

  <div class="nav-scroller py-1 mb-2">
    <nav class="nav d-flex justify-content-between ">
      <a class="p-2 link-secondary" href="/">This Edition</a>
      <a class="p-2 link-secondary" href="/appliedmath">Applied Math</a>
      <a class="p-2 link-secondary" href="/computerscience">Computer Science</a>
      <a class="p-2 link-secondary" href="/features">Features</a>
      <a class="p-2 link-secondary" href="/problemsolving">Problem Solving</a>
      <a class="p-2 link-secondary" href="/puzzles">Puzzles</a>
      <a class="p-2 link-secondary" href="/research">Research</a>
      <a class="p-2 link-secondary" href="/editions">Editions</a>
      <a class="p-2 link-secondary" href="/staff">Staff</a>
    </nav>
  </div>
</div>

<main class="container-fluid">
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<center><header id="title-block-header">
<h1 class="title">Data Structures and Algorithms - The Segment Tree</h1>
<p class="author">Naowal Rahman</p>
</header></center>
<h1 class="unnumbered" id="introduction">Introduction</h1>
<p>In the world of computer science, there are data structures that can store data in special ways which go hand in hand with algorithms that traverse these data structures and perform operations on them. While there are many data structures and algorithms that are widely used and heard of, one data structure in particular is especially interestingthe segment tree. This data structure allows fast range queries over an array whilst also being very flexible. Arrays can be modified very easily and quickly with this data structure, and it can solve huge numbers of problems. Furthermore, this data structure especially shines when using arrays of much larger dimensions, mainly due to the fact that it only requires <span class="math inline">\(\mathcal{O}(n\log n)\)</span> memory. The segment tree is a very useful data structure, and is worth taking a look at.</p>
<h1 class="unnumbered" id="how-it-works">How It Works</h1>
<p>Suppose we needed to efficiently answer sum queries with just one data structure on an array <span class="math inline">\(\{a_0, a_1,\dots, a_{n-1}\}\)</span>, where <span class="math inline">\(n\)</span> is the length of the array. We should be able to use a segment tree to find the sum of elements between two indexes <span class="math inline">\(s\)</span> and <span class="math inline">\(e\)</span>, the start index and end index.<br />
<br />
The key to this data structure is the word “segment". Essentially, after calculating the sum of all the items in the entire array, it will then be split up into a tree of segments, the first of which are <span class="math inline">\(\{a_0,\dots, \frac n2\}\)</span> and <span class="math inline">\(\{\frac n2 + 1, \dots, n-1\}\)</span>. The first split is the first half of the array, since the <span class="math inline">\(e\)</span> index is the half the length of the list. The other split will simply be the second half of the array, since the <span class="math inline">\(s\)</span> index is the half the length of the array plus <span class="math inline">\(1\)</span>. This is to be continued until it isn’t logically possible. In other words, the segmentation stops when <span class="math inline">\(s = e\)</span>. In this case, we’ll take <span class="math inline">\(s\)</span> to be index 0 (the start of the array), and <span class="math inline">\(e\)</span> to be index -1 (the end of the array) This forms a binary tree, as each vertex branching from the root will always have two child vertices, and it also means that the number of vertices will be linear. Visually represented, if the array <span class="math inline">\(\{-3, 2, 4, 9, 6, -8\}\)</span> was given, the tree would look something like this, where the <span class="math inline">\(\{0...n-1\}\)</span> segment contains all indexes in the array and holds the the total sum of the array:</p>
<center><figure>
<img src="/articles/computerscience/Vol3_No1/data-structures/segment-image-tree.png" style="width: 45%; min-width: 300px;" alt="Segment tree of \{-3, 2, 4, 9, 6, -8\}" /><figcaption aria-hidden="true">Segment tree of <span class="math inline">\(\{-3, 2, 4, 9, 6, -8\}\)</span></figcaption>
</figure></center>
<p>Since segment trees follow this branched structure, whenever the length of the array, <span class="math inline">\(n\)</span>, is not a power of 2, not all levels of the segment tree will be equally or completely filled. In general, however, the height of any segment tree will be <span class="math inline">\(O(\log n)\)</span> due to the fact that the size of the segments is cut in half for every level that you go down the tree.</p>
<h1 class="unnumbered" id="implementation">Implementation</h1>
<p>Now that we’ve seen the logic behind a segment tree, lets implement one in Python to answer our sum queries. After importing necessary modules, and , the first step is to implement a function to get the middle index of the array from the bounds <span class="math inline">\(s\)</span> and <span class="math inline">\(e\)</span>.</p>
<div class="sourceCode" id="cb1" data-language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> ceil, log2</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> getMid(s, e): </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s <span class="op">+</span> (e <span class="op">-</span> s) <span class="op">//</span> <span class="dv">2</span> </span></code></pre></div>
<p>We can then create a recursive function to get the sum of values in the given range of the array. This function requires a variety of parameters, where is the pointer to the segment tree, is the index of the current node, and are the starting and ending indexes represented by the current node, and and are the starting and ending indices of the queried range.<br />
<br />
In this function, if a segment of the given node is a part of the given range, then the sum of the segment should be returned. If the segment of the node is outside the given range, the function returns 0. If a part of the segment overlaps with the given range, then we get the mid of and using the function we defined previously and recursively call this function until one of the previous conditionals become true.</p>
<div class="sourceCode" id="cb2" data-language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> getSumUtil(st, ss, se, qs, qe, si): </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (qs <span class="op">&lt;=</span> ss <span class="kw">and</span> qe <span class="op">&gt;=</span> se): </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> st[si]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (se <span class="op">&lt;</span> qs <span class="kw">or</span> ss <span class="op">&gt;</span> qe): </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span> </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> getMid(ss, se)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2 * si + 1 and 2 * si + 2 are the child nodes of si</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (getSumUtil(st, ss, mid, qs, qe, <span class="dv">2</span> <span class="op">*</span> si <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>           getSumUtil(st, mid <span class="op">+</span> <span class="dv">1</span>, se, qs, qe, <span class="dv">2</span> <span class="op">*</span> si <span class="op">+</span> <span class="dv">2</span>))</span></code></pre></div>
<p>The next step is to define a recursive function that will update nodes that have the given indexes, and , in their range. For this function, two new parameters, and , need to be introduced. The first one, , is the index of the element to be updated. The second one, , is the value to be added to all nodes which have index in their range.<br />
<br />
The function will return nothing as a base case if the input index lies outside the range of the given segment. If the input index is in the range of the given node, the we need to update the value of this node and its children. In essence, this function is used to update the segment tree. By recursively calling this function on the child nodes of the current node, which are indicated by indices and , a loop is created and it continues until the input index lies outside the range of the given segment.</p>
<div class="sourceCode" id="cb3" data-language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> updateValueUtil(st, ss, se, i, diff, si): </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i <span class="op">&lt;</span> ss <span class="kw">or</span> i <span class="op">&gt;</span> se): </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span> </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    st[si] <span class="op">=</span> st[si] <span class="op">+</span> diff</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> se <span class="op">!=</span> ss: </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> getMid(ss, se) </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        updateValueUtil(st, ss, mid, i, diff, <span class="dv">2</span> <span class="op">*</span> si <span class="op">+</span> <span class="dv">1</span>) </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        updateValueUtil(st, mid <span class="op">+</span> <span class="dv">1</span>, se, i, diff, <span class="dv">2</span> <span class="op">*</span> si <span class="op">+</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Using this function, another function can be created that will update a value in the input array and thus the segment tree. Nothing is returned if the input index is invalid. Otherwise, the function will proceed to get the difference between the new and old values and then update the value in the array. Finally, it will update the values of the nodes in the segment tree. This allows for easy update queries within the segment tree. While using utility functions within other functions is an unnecessary part of the implementation, they make it much easier.</p>
<div class="sourceCode" id="cb4" data-language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> updateValue(arr, st, n, i, new_val): </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> i <span class="op">&gt;</span> n): </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;invalid input&quot;</span>, end <span class="op">=</span> <span class="st">&quot;&quot;</span>) </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> new_val <span class="op">-</span> arr[i] </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    arr[i] <span class="op">=</span> new_val</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    updateValueUtil(st, <span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>, i, diff, <span class="dv">0</span>)</span></code></pre></div>
<p>To answer sum queries, a function will be created that uses the previously define utility function that returns the sum. The point of having this function make use of a utility function is to ensure that there are no erroneous input values. Thus, the code is not only much cleaner but also less prone to error. If there are any values that are erroneous, -1 is returned but otherwise the output of the sum utility function is returned. In essence, the sum of elements in the range of index to is being returned.</p>
<div class="sourceCode" id="cb5" data-language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> getSum(st, n, qs, qe): </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (qs <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> qe <span class="op">&gt;</span> n <span class="op">-</span> <span class="dv">1</span> <span class="kw">or</span> qs <span class="op">&gt;</span> qe):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;invalid input&quot;</span>, end <span class="op">=</span> <span class="st">&quot;&quot;</span>) </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span> </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> getSumUtil(st, <span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>, qs, qe, <span class="dv">0</span>) </span></code></pre></div>
<p>With all the functions to perform operations on the segment tree finished, the only thing left to do is to actually construct a segment tree. First, a recursive utility function is needed that constructs a segment tree given an array . Here, parameter is the index of the current node in the segment tree . If there is one element in the array, the function will store it in the current node of the segment tree and return the value of the starting index . However, if more than 1 element is present, the function will get the middle index of the array and recursively call the child nodes on the left and right, storing the sum of the values in the given node.</p>
<p>Then, a final constructor function is needed to make use of this utility function. It finds the height of the segment tree, calculates the maximum size, allocates the required memory, and fills the allocated memory with segment tree , returning the segment tree using the constructor utility function.</p>
<div class="sourceCode" id="cb6" data-language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> constructSTUtil(arr, ss, se, st, si):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ss <span class="op">==</span> se: </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        st[si] <span class="op">=</span> arr[ss]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr[ss]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> getMid(ss, se) </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    st[si] <span class="op">=</span> (constructSTUtil(arr, ss, mid, st, si <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>             constructSTUtil(arr, mid <span class="op">+</span> <span class="dv">1</span>, se, st, si <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> st[si]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> constructST(arr, n):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="bu">int</span>(ceil(log2(n)))</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    max_size <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="bu">int</span>(<span class="dv">2</span> <span class="op">**</span> x) <span class="op">-</span> <span class="dv">1</span> </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    st <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> max_size </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    constructSTUtil(arr, <span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>, st, <span class="dv">0</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> st </span></code></pre></div>
<p>With that, everything needed to make a segment tree is finished. We can put some driver code need to actually make use of it. First, we build the segment tree from the given array and answer a sum query given a starting and ending index. Then, we can perform update queries on the segment tree by updating a given index and its corresponding nodes, and then finding the new value after it is updated.</p>
<div class="sourceCode" id="cb7" data-language="Python"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> [<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">9</span>, <span class="dv">6</span>, <span class="op">-</span><span class="dv">8</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr) </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    st <span class="op">=</span> constructST(arr, n)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;sum: &quot;</span>, getSum(st, n, <span class="dv">2</span>, <span class="dv">5</span>))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    updateValue(arr, st, n, <span class="dv">3</span>, <span class="dv">12</span>) </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;updated sum: &quot;</span>, getSum(st, n, <span class="dv">2</span>, <span class="dv">5</span>), end <span class="op">=</span> <span class="st">&quot;&quot;</span>) </span></code></pre></div>
<p>The final output is <span class="math inline">\(11\)</span>, as this is the sum of the given values, and subsequently <span class="math inline">\(14\)</span>, as it’s the updated sum of the values. This is correct, as the sum of all the numbers from index <span class="math inline">\(2\)</span> to <span class="math inline">\(5\)</span> is <span class="math inline">\(11\)</span>, and when index <span class="math inline">\(3\)</span> is updated to <span class="math inline">\(12\)</span>, the sum increases by 3 to 14.</p>
<h1 class="unnumbered" id="conclusion">Conclusion</h1>
<p>The segment tree has proved to be very interesting, and its features allow for efficient queries of various types. Its binary tree like methodology allows for time complexities far superior than that of other data structures and algorithms that use loops and perform operations linearly. Hopefully, this introduction to segment trees has shown you a different and unique view at the world of data structures and algorithms.</p>
</main>
</body>
</html>
